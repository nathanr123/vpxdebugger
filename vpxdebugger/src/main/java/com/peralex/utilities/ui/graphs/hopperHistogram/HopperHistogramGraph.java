package com.peralex.utilities.ui.graphs.hopperHistogram;

import java.awt.BorderLayout;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.ResourceBundle;

import javax.swing.JPanel;

import com.peralex.utilities.locale.ILocaleListener;
import com.peralex.utilities.locale.PeralexLibsBundle;
import com.peralex.utilities.ui.graphs.hopperHistogram.dualChannel.HistogramDualChannel;
import com.peralex.utilities.ui.graphs.hopperHistogram.singleChannel.HistogramSingleChannel;

/**
 * This class creates a new HopperHistogramGraph.
 *
 * @author Andre E
 */
public class HopperHistogramGraph extends JPanel implements ILocaleListener
{
	private ResourceBundle textRes = PeralexLibsBundle.getResource();
  
  /**
   * The current Histogram.
   */
  private IHopperHistogram oHistogram;
	
  /**
   * Indicates a Single Channel histogram.
   */
  public static final int SINGLE_CHANNEL = 1;
  
  /**
   * Indicates a Dual Channel histogram.
   */
  public static final int DUAL_CHANNEL = 2;
 
  /**
   * Stores the oHistogramDataActive Listeners
   */
  private final List<IHistogramDataActiveListener> oHistogramDataActiveListeners = new ArrayList<IHistogramDataActiveListener>();
	
	/**
	 * Number of channels for this graph
	 */
	private int iNumberOfChannels = DUAL_CHANNEL;
  
  /**
   * Creates new form cHopperHistogramGraph.
   */
  public HopperHistogramGraph()
  {
    this(DUAL_CHANNEL);
  }

  /**
   * Creates new form cHopperHistogramGraph
   */
  public HopperHistogramGraph(int iNumberOfChannels)
  {
		this.iNumberOfChannels = iNumberOfChannels;
		
    initComponents();

    if (iNumberOfChannels == DUAL_CHANNEL)
    {
      oHistogram = new HistogramDualChannel();
    }
    else 
    {
      oHistogram = new HistogramSingleChannel();
      
      setYAxisRange(0, 3);
      setYAxisText(textRes.getString("HopperHistogram.Probability_factor"));
    }
    
    add((JPanel)oHistogram, BorderLayout.CENTER);
    
		PeralexLibsBundle.addLocaleListener(this); //do after components have been initialised
  }
  
  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  private void initComponents()//GEN-BEGIN:initComponents
  {
    java.awt.GridBagConstraints gridBagConstraints;

    oJPanel = new javax.swing.JPanel();
    oEnableHistogramCheckBox = new javax.swing.JCheckBox();

    setLayout(new java.awt.BorderLayout());

    oJPanel.setLayout(new java.awt.GridBagLayout());

    oEnableHistogramCheckBox.setText(textRes.getString("HopperHistogram.Enable_Hopper_Histogram"));
    oEnableHistogramCheckBox.addItemListener(new java.awt.event.ItemListener()
    {
      public void itemStateChanged(java.awt.event.ItemEvent evt)
      {
        oEnableHistogramCheckBoxItemStateChanged(evt);
      }
    });

    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 0);
    oJPanel.add(oEnableHistogramCheckBox, gridBagConstraints);

    add(oJPanel, java.awt.BorderLayout.NORTH);

  }//GEN-END:initComponents

  private void oEnableHistogramCheckBoxItemStateChanged(@SuppressWarnings("unused") java.awt.event.ItemEvent evt)//GEN-FIRST:event_oEnableHistogramCheckBoxItemStateChanged
  {//GEN-HEADEREND:event_oEnableHistogramCheckBoxItemStateChanged
    notifyHistogramDataActiveListeners(oEnableHistogramCheckBox.isSelected());
  }//GEN-LAST:event_oEnableHistogramCheckBoxItemStateChanged
  
	public void addHistogramDataActiveListener(IHistogramDataActiveListener oHistogramDataActiveListener)
	{
		oHistogramDataActiveListeners.add(oHistogramDataActiveListener);
	}
	
	public void removeHistogramDataActiveListener(IHistogramDataActiveListener oHistogramDataActiveListener)
	{
		oHistogramDataActiveListeners.remove(oHistogramDataActiveListener);
	}
	
	private void notifyHistogramDataActiveListeners(boolean bActive)
	{
		for (IHistogramDataActiveListener listener : oHistogramDataActiveListeners)
		{
			listener.histogramDataActiveChanged(this, bActive);
		}
	}
  
  /**
   * This method passes new data into the Histogram.
   *
   * @param asDimensionName the name of the dimension
   * @param asDimensionUnitName the name of units for the dimension
   * @param awNumPoints the number of points in the histogram for this dimension (ns)
   * @param afMinScaleValue minimum value for the scale of the dimension
   * @param afMaxScaleValue maximum value for the scale of the dimension
   * @param abIsLogarithmic is the dimension's scale logarithmic?
   * @param afHistogramData histogram data 
   */
  public synchronized void onDataReceived(String[] asDimensionName, String[] asDimensionUnitName, short[] awNumPoints, float[] afMinScaleValue, float[] afMaxScaleValue, boolean[] abIsLogarithmic, float[] afHistogramData)
  {
    oHistogram.onDataReceived(asDimensionName, asDimensionUnitName, awNumPoints, afMinScaleValue, afMaxScaleValue, abIsLogarithmic, afHistogramData);
  }
  
  /**
   * This methods sets the XAxisRange.
   *
   * @param dXAxisMinimum contains the minimum
   * @param dXAxisMaximum contains the maximum
   * @param dYAxisMinimum contains the minimum
   * @param dYAxisMaximum contains the maximum
   */
  public synchronized void setAxisRanges(double dXAxisMinimum, double dXAxisMaximum, double dYAxisMinimum, double dYAxisMaximum)
  {       
    
    oHistogram.setAxisRanges(dXAxisMinimum, dXAxisMaximum, dYAxisMinimum, dYAxisMaximum);
  }
  
  /**
   * This methods sets the XAxisRange.
   *
   * @param dXAxisMinimum contains the minimum
   * @param dXAxisMaximum contains the maximum
   */
  public synchronized void setXAxisRange(double dXAxisMinimum, double dXAxisMaximum)
  {       
    oHistogram.setXAxisRange(dXAxisMinimum, dXAxisMaximum);
  }
  
  /**
   * This methods sets the YAxisRange.
   *
   * @param dYAxisMinimum contains the minimum
   * @param dYAxisMaximum contains the maximum
   */
  public final synchronized void setYAxisRange(double dYAxisMinimum, double dYAxisMaximum)
  {       
    oHistogram.setYAxisRange(dYAxisMinimum, dYAxisMaximum);
  }  
  
  /**
   * Get the XAxis Minimum.
   *
   * @return dMinX.
   */
  public double getXAxisMinimum()
  {
    return oHistogram.getXAxisMinimum();
  }
  
  /**
   * Get the XAxis Maximum.
   *
   * @return dMaxX.
   */
  public double getXAxisMaximum()
  {
    return oHistogram.getXAxisMaximum();
  }  

  /**
   * Get the YAxis Minimum.
   *
   * @return dMinY.
   */
  public double getYAxisMinimum()
  {
    return oHistogram.getYAxisMinimum();
  }
  
  /**
   * Get the YAxis Maximum.
   *
   * @return dMaxY.
   */
  public double getYAxisMaximum()
  {
    return oHistogram.getYAxisMaximum();
  }

  /**
   * Set the Title of the Histogram.
   *
   * @param sTitleText
   */
  public void setTitle(String sTitleText)
  {
    oHistogram.setTitle(sTitleText);
  }
  
  /**
   * Get the Title of the Histogram.
   *
   * @return sTitleText
   */
  public String getTitle()
  {
    return oHistogram.getTitle();
  }
  
  /**
   * Set the Text of the X-Axis.
   *
   * @param sXAxisText
   */
  public void setXAxisText(String sXAxisText)
  {
    oHistogram.setXAxisText(sXAxisText);
  }
  
  /**
   * Get the Text of the X-Axis.
   *
   * @return XAxisTitle
   */
  public String getXAxisText()
  {
    return oHistogram.getXAxisText();
  }
  
  /**
   * Set the Text of the Y-Axis.
   *
   * @param sYAxisText
   */
  public final void setYAxisText(String sYAxisText)
  {
    oHistogram.setYAxisText(sYAxisText);
  }
  
  /**
   * Get the Text of the Y-Axis.
   *
   * @return YAxisTitle
   */
  public String getYAxisText()
  {
    return oHistogram.getYAxisText();
  }    
  
  /**
   * This method is used to Clear the Histogram.
   */
  public synchronized void clear()
  {
    oHistogram.clear();
  }
  
  /**
   * This method sets the Background color of this Histogram.
   *
   * @param oBackgroundColor contains the new color.
   */
  public void setBackgroundColor(Color oBackgroundColor)
  {
    oHistogram.setBackgroundColor(oBackgroundColor);
  }
  
  /**
   * This method sets the Grid Color of this Histogram.
   *
   * @param oGridColor contains the new color.
   */
  public void setGridColor(Color oGridColor)
  {
    oHistogram.setGridColor(oGridColor);
  }
	
  /**
   * This method is called when the locale has been changed. The listener should
	 * then update the visual components.
   */
	public void componentsLocaleChanged()
	{
		textRes = PeralexLibsBundle.getResource();
		
		if (iNumberOfChannels == SINGLE_CHANNEL)
		{
			setYAxisText(textRes.getString("HopperHistogram.Probability_factor"));
		}
		oEnableHistogramCheckBox.setText(textRes.getString("HopperHistogram.Enable_Hopper_Histogram"));
		repaint();
	}
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JCheckBox oEnableHistogramCheckBox;
  private javax.swing.JPanel oJPanel;
  // End of variables declaration//GEN-END:variables

  public interface IHistogramDataActiveListener
  {
    
    /**
     * Sets the Histogram DataActive status.
     */
    void histogramDataActiveChanged(HopperHistogramGraph graph, boolean bActive);
  }
}
